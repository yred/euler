# -*- coding: utf-8 -*-
"""
Problem 101 - Optimum polynomial

If we are presented with the first k terms of a sequence it is impossible to
say with certainty the value of the next term, as there are infinitely many
polynomial functions that can model the sequence.

As an example, let us consider the sequence of cube numbers. This is defined by
the generating function,

            u(n) = n^3: 1, 8, 27, 64, 125, 216, ...

Suppose we were only given the first two terms of this sequence. Working on the
principle that "simple is best" we should assume a linear relationship and
predict the next term to be 15 (common difference 7). Even if we were presented
with the first three terms, by the same principle of simplicity, a quadratic
relationship should be assumed.

We shall define OP(k, n) to be the nth term of the optimum polynomial
generating function for the first k terms of a sequence. It should be clear
that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, and
potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we
shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence, it would be most
sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u(1).

Hence we obtain the following OPs for the cubic sequence:

            OP(1, n) = 1                    1, (1), 1, 1, ...
            OP(2, n) = 7*n − 6              1, 8, (15), ...
            OP(3, n) = 6*n^2 − 11*n + 6     1, 8, 27, (58), ...
            OP(4, n) = n^3                  1, 8, 27, 64, 125, ...

Clearly no BOPs exist for k ≥ 4.

By considering the sum of FITs generated by the BOPs (in parentheses above), we
obtain 1 + 15 + 58 = 74.

Consider the following tenth degree polynomial generating function:

    u(n) = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10

Find the sum of FITs for the BOPs.
"""


class Polynomial(object):

    def __init__(self, coefficients):
        self.coeffs = coefficients

    def __getitem__(self, n):
        """Returns the coefficient of the n-th term of the polynomial"""
        return self.coeffs[n] if n < len(self.coeffs) else 0

    def __setitem__(self, n, value):
        if n < len(self.coeffs):
            self.coeffs[n] = value
        else:
            self.coeffs.extend([0]*(n - len(self.coeffs)) + [value])

    def __iter__(self):
        return iter(self.coeffs)

    def __call__(self, x):
        """Returns the result of evaluating the polynomial at x"""
        return sum(c*(x**i) for i, c in enumerate(self))

    @property
    def degree(self):
        return len(self.coeffs) - 1


class Equation(object):
    """
    Represents equations of the form:  a*x0 + b*x1 + ... + c*xN = d, where x0,
    x1, ..., xN are the unknowns
    """

    def __init__(self, left, right):
        self.left = left
        self.right = right

    def substitution(self, index):
        """
        Returns an instance of Equation that can be used to substitute/remove
        the variable at `index` via (scaled) addition
        """
        coeff = self.left[index]

        # If the coefficient at `index` is 0, no meaningful value can be
        # returned
        if coeff == 0:
            raise ValueError('The substitution term must not equal 0')

        return Equation(left=[-1.0*elem/coeff if idx != index else -1
                              for idx, elem in enumerate(self.left)],
                        right=-self.right/coeff)

    def __getitem__(self, n):
        return self.left[n]

    def __setitem__(self, n, value):
        self.left[n] = value

    def __add__(self, other):
        if not isinstance(other, Equation):
            raise TypeError('Both operands must be of type Equation')

        return Equation(left=[s + o for s, o in zip(self.left, other.left)],
                        right=self.right + other.right)

    def __iadd__(self, other):
        return self + other

    def __rmul__(self, scalar):
        return Equation(left=[scalar*elem for elem in self.left],
                        right=scalar*self.right)


def optimum(seq):
    """
    Returns the coefficients of the optimum polynomial based on the terms of
    the sequence `seq`
    """
    # Degree of the optimum polynomial
    deg = len(seq) - 1

    equations = [Equation(left=[(n+1)**i for i in range(deg+1)], right=seq[n])
                 for n in range(deg+1)]

    # Using substitution, transform the above system of equations into a
    # triangular one
    for i in range(deg):
        sub = equations[i].substitution(i)

        for j in range(i+1, deg+1):
            equations[j] += equations[j][i]*sub

    coeffs = []

    # Moving from the last equation backwards, solve for the only remaining
    # variable and "plug" its value into the preceding equations
    for i in reversed(range(deg+1)):
        coeff = equations[i].right*1.0 / equations[i][i]

        for j in range(i):
            equations[j].right -= coeff*equations[j][i]
            equations[j][i] = 0

        coeffs.append(coeff)

    return coeffs[::-1]


def solution():
    P = Polynomial([(-1)**i for i in range(11)])
    seq = [P(n+1) for n in range(P.degree)]

    return sum(Polynomial(optimum(seq[:i+1]))(i+2) for i in range(len(seq)))


if __name__ == '__main__':
    print(solution())
