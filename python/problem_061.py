# -*- coding: utf-8 -*-
"""
Problem 61 - Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

    Triangle        P3(n) = n(n+1)/2        1, 3, 6, 10, 15, ...
    Square          P4(n) = n^2             1, 4, 9, 16, 25, ...
    Pentagonal      P5(n) = n(3n−1)/2       1, 5, 12, 22, 35, ...
    Hexagonal       P6(n) = n(2n−1)         1, 6, 15, 28, 45, ...
    Heptagonal      P7(n) = n(5n−3)/2       1, 7, 18, 34, 55, ...
    Octagonal       P8(n) = n(3n−2)         1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

    -   The set is cyclic, in that the last two digits of each number is the
        first two digits of the next number (including the last number with the
        first).

    -   Each polygonal type: triangle (P3(127)=8128), square (P4(91)=8281), and
        pentagonal (P5(44)=2882), is represented by a different number in the
        set.

    -   This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
"""
from collections import defaultdict
from itertools import dropwhile, takewhile, permutations

from common.sequences import *


def solution():
    fst2 = defaultdict(lambda: defaultdict(list))
    lst2 = defaultdict(lambda: defaultdict(list))

    # set of polygonal/figurate numbers
    ps = (triangles, squares, pentagonals, hexagonals, heptagonals, octagonals)

    # Octagonals will be used as the starting point of the search for the
    # cycle, as they grow fastest and are thus the fewest to iterate through
    octas = []

    for index, polygonal in enumerate(ps, start=3):
        for n in takewhile(lambda n: n < 10000,
                           dropwhile(lambda n: n < 1000, iter(polygonal))):

            if index == 8:
                octas.append(n)
            else:
                fst2[n / 100][index].append(n)
                lst2[n % 100][index].append(n)

    for octa in octas:
        for p in permutations(range(3, 8)):
            # numbers preceding and succeeding `octa` in the (potential) cycle
            # (i.e., ... <head[2]> <head[1]> octa <tail[1]> <tail[2]> ...)
            head = [set([octa])]
            tail = [set([octa])]

            while p:
                h = set(n for el in head[-1] for n in lst2[el / 100][p[-1]])
                t = set(n for el in tail[-1] for n in fst2[el % 100][p[0]])

                if not h or not t:
                    break

                head.append(h)
                tail.append(t)

                p = p[1:-1]

            else:
                if h & t:
                    # As the problem stated there would only be a unique six
                    # cyclic 4-digit set, the intersection of `h` and `t` must
                    # only contain a single element
                    root = (h & t).pop()

                    cycle = [root]

                    for s in list(reversed(head[:-1])) + tail[1:-1]:
                        for n in (n for n in s if n / 100 == cycle[-1] % 100):
                            cycle.append(n)

                    return sum(cycle)


if __name__ == '__main__':
    print(solution())
